// Omake meta programming language compiler.
// Copyright (C) 2018  Ilmir Usmanov
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

module omake.parser

import {
  omake.lexer
}

data Module(module_str: Name?, imports: Name[], declarations: Declaration[]) {
  rule match : (Token[]) = (Token.Module:_ Name)?:m
                           (Token.Import:_ Token.LeftBrace:_ Name Token.RightBrace:_)*:i
                           Declaration*:d -> `m, i, d`
}

data Name(Token.Identifier[]) {
  rule match : (Token[]) = Token.Identifier (Token.Dot:_ Token:Identifier)*
}

data Declaration { rule match : (Token[]) }
= Data(Data)     { = Token.Data:_ Data }
| Rule(Rule)     { = Token.Rule:_ Rule }

data Data(header: DataHeader, methods: Rule[], values: DataValue[]) {
  rule match : (Token[]) = Token.Data DataHeader:h
                           (Token.RightBrace:_ (Token.Rule:_ Rule)* Token.RightBrace:_)?:m
                           (Token.Equals:_ DataValue (Token.Or:_ DataValue)*)?:v -> `h, m, v`
}

data DataHeader(name: Token.Identifier, fields: DataField[]) {
  rule match : (Token[]) = Token.Data Token.Identifier:i
                           (Token.LeftParen:_ DataField (Token.Comma:_ DataField)? Token.RightParen:_)?:f -> `i, f`
}

data DataField(name: Name?, type: Type) {
  rule match : (Token[]) = Name?:n Token.Colon Type:t -> `n, t`
}

data Type(Name) { rule match : (Token[])                      }
= Optional      { Name Token.Query:_                          }
| Array         { Name Token.LeftSquare:_ Token:RightSquare:_ }
| Normal        { Name                                        }

data DataValue(header: DataHeader, methods: RuleBody[]) {
  rule match : (Token[]) = DataHeader:h (Token.LeftBrace:_ (Token.Equals:_ RuleBody)* Token.RightBrace:_)?:r -> `h, r`
}

data Rule(name: Name, input_types: Type[], result_type: Type?, body: RuleBody) {
  rule match : (Token[]) = Name:n Token.Colon:_
                           (Token.LeftParen:_ (Type (Token.Comma:_ Type)*)? Token.RightParen:_):it
                           RuleBody:rb -> `n, it, rb`
}

data RuleBody(RulePart[]) {
  rule match : (Token[]) = RulePart (Token.Or:_ RulePart)*
}

data RulePart(Atom[], action: Token.Raw?) {
  rule match : (Token[]) = Token.Raw                           -> `null, result`
                         | Atom+:p (Token.Arrow:_ Token.Raw):r -> `p, r`
}

data Atom(PostfixAtom, name: Name?) {
  rule match : (Token[]) = PostfixAtom:p (Token.Colon:_ Name):n -> `p, n`
}

data PostfixAtom(SimpleAtom) { match : (Token[])        }
= ZeroOrOne                  { SimpleAtom Token.Query:_ }
| ZeroOrMore                 { SimpleAtom Token.Star:_  }
| OneOrMore                  { SimpleAtom Token.Plus:_  }
| Simple                     { SimpleAtom               }

data SimpleAtom   { match : (Token[])                          }
= Compound(Atom)  { Token.LeftParen:_ Atom+ Token.RightParen:_ }
| Name(Name)      { Name                                       }
