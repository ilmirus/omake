// Omake meta programming language compiler.
// Copyright (C) 2018  Ilmir Usmanov
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

module omake.parser

import {
  omake.lexer
}

data Module(module_str: Name?, imports: Name[], declarations: Declaration[]) {
  rule match : (Token[]) = [[Token.Module:_ Name:m]?
                            [Token.Import:_ Token.LeftBrace:_ Name*:i Token.RightBrace:_]?
                            Declaration*:d] -> `Module(m, i, d)`
  rule meta : (this) -> void = Module(., [.*], [Declaration.meta*])
}

data Name(Token.Identifier[]) {
  rule match : (Token[]) = [Token.Identifier [Token.Dot:_ Token:Identifier]*]
}

data Declaration = Data(Data) | Rule(Rule) {
  rule match : (Token[]) = [Token.Data:_ Data] -> `Data(result)`
                         | [Token.Rule:_ Rule] -> `Rule(result)`
}

data Data(header: DataHeader, values: DataHeader[], methods: Rule[]) {
  rule match : (Token[]) = [Token.Data DataHeader:h
                            [Token.Equals:_ DataHeader [Token.Or:_ DataHeader]*]?:v
                            [Token.RightBrace:_ [Token.Rule:_ Rule]* Token.RightBrace:_]?:m] -> `Data(h, v, m)`
  rule meta : (this) -> void = Data(DataHeader(:name, DataField.meta:_), [.*],
                                    [[.*:_ Rule(Name([Token.Identifier("match")]), [.*], ., .)]:m])
                             -> `m.result_type = Type.Normal(name)`
}

data DataHeader(name: Token.Identifier, fields: DataField[]) {
  rule match : (Token[]) = [Token.Data Token.Identifier:i
                            [Token.LeftParen:_ DataField [Token.Comma:_ DataField]* Token.RightParen:_]?:f] -> `DataHeader(i, f)`
  rule meta : (this) -> void = DataHeader(., [DataField.meta*])
}

data DataField(name: Name?, type: Type) {
  rule match : (Token[]) = [Name?:n Token.Colon Type:t] -> `DataField(n, t)`
  rule meta : (this) -> () = this(null, .) -> `name = Name.Normal("value")`
}

data Type(Name) = Optional | Array | Normal {
  rule match : (Token[]) = [Name Token.Query:_]                          -> `Optional(result)`
                         | [Name Token.LeftSquare:_ Token:RightSquare:_] -> `Array(result)`
                         | [Name]                                        -> `Normal(name)`
}

data DataValue(header: DataHeader, methods: RuleBody[]) {
  rule match : (Token[]) = [DataHeader:h [Token.LeftBrace:_ [Token.Equals:_ RuleBody]* Token.RightBrace:_]?:r] -> `DataValue(h, r)`
}

data Rule(name: Name, input_types: Type[], result_type: Type?, body: RuleBody) {
  rule match : (Token[]) = [Name:n Token.Colon:_
                            [Token.LeftParen:_ [Type [Token.Comma:_ Type]*]? Token.RightParen:_]:it
                            [Token.Arrow:_ Type]:rt
                            RuleBody:rb] -> `Rule(n, it, rt, rb)`
}

data RuleBody(RulePart[]) {
  rule match : (Token[]) = [RulePart [Token.Or:_ RulePart]*] -> `RuleBody(result)`
}

data RulePart(NamedExpr, action: Token.Raw?) {
  rule match : (Token[]) = Token.Raw                                  -> `RulePart(null, result)`
                         | [NamedExpr:p [Token.Arrow:_ Token.Raw:r]?] -> `RulePart(p, r)`
}

data NamedExpr(Pattern?, name: Name?) {
  rule match : (Token[]) = [Pattern:p [Token.Colon:_ Name:n]?] -> `NamedExpr(p, n)`
                         | [Token.Colon:_ Name:n             ] -> `NamedExpr(null, n)`
}

data Pattern(Primary) = ZeroOrOne | ZeroOrMore | OneOrMore | Primary {
  rule match : (Token[]) = [Primary Token.Query:_] -> `ZeroOrOne(result)`
                         | [Primary Token.Star:_]  -> `ZeroOrMore(result)`
                         | [Primary Token.Plus:_]  -> `OneOrMore(result)`
                         | [Primary]               -> `Primary(result)`
}

data Primary = Destructuring(name, subexprs: NamedExpr[])
             | Sequence(NamedExpr[]) | Name(Name)
             | Range(left: Token.Literal, right: Token.Literal)
             | Literal(Token.Literal) | Dot | Dollar {
  rule match : (Token[]) = [Name:n Token.LeftParen [NamedExpr [Token.Comma NamedExpr]*]:s Token.RightBrace] -> `Destructuring(n, s)`
                         | [Token.LeftSquare NamedExpr*:n Token.RightSquare]                                -> `Sequence(n)`
                         | [Name]                                                                           -> `Name(result)`
                         | [Token.Literal:l Token.DotDot Token.Literal:r]                                   -> `Range(l, r)`
                         | [Token.Literal]                                                                  -> `Literal(result)`
                         | [Token.Dot]                                                                      -> `Dot`
                         | [Token.Dollar]                                                                   -> `Dollar`
}