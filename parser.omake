// Omake meta programming language compiler.
// Copyright (C) 2018  Ilmir Usmanov
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

module omake.parser

import {
  omake.lexer
}

data Module(module_str: Name?, imports: Name[], declarations: Declaration[]) {
  rule match : (Token[]) = [[Token.Module:_ Name:m]?
                            [Token.Import:_ Token.LeftBrace:_ Name*:i Token.RightBrace:_]?
                            Declaration*:d] -> `m, i, d`
  rule meta : (this) -> void = this(., ., [Declaration.meta*])
}

data Name(Token.Identifier[]) {
  rule match : (Token[]) = [Token.Identifier [Token.Dot:_ Token:Identifier]*]
}

data Declaration { rule match : (Token[]) rule meta : (this) -> void }
= Data(Data)     { = [Token.Data:_ Data]  = this.Data(Data.meta) }
| Rule(Rule)     { = [Token.Rule:_ Rule]  = this.Rule(Rule.meta) }

data Data(header: DataHeader, methods: Rule[], values: DataValue[]) {
  rule match : (Token[]) = [Token.Data DataHeader:h
                            [Token.RightBrace:_ [Token.Rule:_ Rule]* Token.RightBrace:_]?:m
                            [Token.Equals:_ DataValue [Token.Or:_ DataValue]*]?:v] -> `h, m, v`
  rule meta : (this) -> void = `fill_match_return_type(); fill_match_rule_results();`
  rule fill_match_return_type : (this) -> void = this(DataHeader(:name, DataField.meta:_), find_match:m, .)
                                               -> `m.result_type = Type.Normal(name)`
  rule fill_match_rule_results : (this) -> void = TODO
}

data DataHeader(name: Token.Identifier, fields: DataField[]) {
  rule match : (Token[]) = [Token.Data Token.Identifier:i
                            [Token.LeftParen:_ DataField [Token.Comma:_ DataField]* Token.RightParen:_]?:f] -> `i, f`
  rule meta : (this) -> void = this(., [DataField.meta*])
}

data DataField(name: Name?, type: Type) {
  rule match : (Token[]) = [Name?:n Token.Colon Type:t] -> `n, t`
  rule meta : (this) -> () = this(null, _) -> `name = Name.Normal("value")`
}

data Type(Name) { rule match : (Token[])                          }
= Optional      { = [Name Token.Query:_                         ] }
| Array         { = [Name Token.LeftSquare:_ Token:RightSquare:_] }
| Normal        { = [Name                                       ] }

data DataValue(header: DataHeader, methods: RuleBody[]) {
  rule match : (Token[]) = [DataHeader:h [Token.LeftBrace:_ [Token.Equals:_ RuleBody]* Token.RightBrace:_]?:r] -> `h, r`
}

data Rule(name: Name, input_types: Type[], result_type: Type?, body: RuleBody) {
  rule match : (Token[]) = [Name:n Token.Colon:_
                            [Token.LeftParen:_ [Type [Token.Comma:_ Type]*]? Token.RightParen:_]:it
                            [Token.Arrow:_ Type]:rt
                            RuleBody:rb] -> `n, it, rt, rb`
}

data RuleBody(RulePart[]) {
  rule match : (Token[]) = [RulePart [Token.Or:_ RulePart]*]
}

data RulePart(NamedExpr, action: Token.Raw?) {
  rule match : (Token[]) = Token.Raw                                  -> `null, result`
                         | [NamedExpr:p [Token.Arrow:_ Token.Raw:r]?] -> `p, r`
}

data NamedExpr(Pattern?, name: Name?) {
  rule match : (Token[]) = [Pattern:p [Token.Colon:_ Name:n]?] -> `p, n`
                         | [Token.Colon:_ Name:n             ] -> `null, n`
}

data Pattern(Primary) { match : (Token[])         }
= ZeroOrOne           { = [Primary Token.Query:_] }
| ZeroOrMore          { = [Primary Token.Star:_ ] }
| OneOrMore           { = [Primary Token.Plus:_ ] }
| Primary             { = [Primary              ] }

data Primary                                       { match : (Token[])                                                                            }
= Destructuring(name, subexprs: NamedExpr[])       { = [Name:n Token.LeftParen [NamedExpr [Token.Comma NamedExpr]*]:s Token.RightBrace] -> `n, s` }
| Sequence(NamedExpr[])                            { = [Token.LeftSquare NamedExpr* Token.RightSquare                                 ]           }
| Name(Name)                                       { = [Name                                                                          ]           }
| Range(left: Token.Literal, right: Token.Literal) { = [Token.Literal:l Token.DotDot Token.Literal:r                                  ] -> `l, r` }
| Literal(Token.Literal)                           { = [Token.Literal                                                                 ]           }
| Dot                                              { = [Token.Dot                                                                     ]           }
| Dollar                                           { = [Token.Dollar                                                                  ]           }
