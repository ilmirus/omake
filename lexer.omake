// Omake meta programming language compiler.
// Copyright (C) 2018  Ilmir Usmanov
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

module omake.lexer

import (
  omake.error
)

data Locus(raw : long { 1 }, column : long { 1 })
> advance : (this, c : char) -> void
> { if (c != '\n') column++; else { row++; column = 1; } }

data Input(string, locus : Locus { Locus() })
> empty : (this) -> bool :: front : (this) -> dchar            :: popFront : (this) -> void
> { value.empty() }      :: { empty() ? '\0' : value.front() } :: { if (empty()) return; locus.advance(front()); value.popFront(); }

data Token(locus : Locus)
> match : (Input)   -> Token                                    :: toString : (this) -> string
> "::"              | ColonColon(){ input.locus }               :: { "::" }
> ":"               | Colon(){ input.locus }                    :: { ":" }
> (' ' | '\t')*     | Whitespace(){ input.locus }               :: { " " }
> '('               | LeftParen(){ input.locus }                :: { "(" }
> ')'               | RightParen(){ input.locus }               :: { ")" }
> '='               | Assign(){ input.locus }                   :: { "=" }
> "->"              | Arrow(){ input.locus }                    :: { "->" }
> ','               | Comma(){ input.locus }                    :: { "," }
> "data"            | Data(){ input.locus }                     :: { "data" }
> "module"          | Module(){ input.locus }                   :: { "module" }
> "import"          | Import(){ input.locus }                   :: { "import" }
> '['               | LeftSquare(){ input.locus }               :: { "[" }
> ']'               | RightSquare(){ input.locus }              :: { "]" }
> identifier        | Identifier(string){ input.locus, result } :: { value }
> character_literal | Char(char){ input.locus, result }         :: { "'" ~ value ~ "'" }
> string_literal    | String(string){ input.locus, result }     :: { `"` ~ value ~ `"` }
> ".."              | DotDot(){ input.locus }                   :: { ".." }
> '.'               | Dot(){ input.locus }                      :: { "." }
> '|'               | Or(){ input.locus }                       :: { "|" }
> '*'               | Star(){ input.locus }                     :: { "*" }
> '?'               | Query(){ input.locus }                    :: { "?" }
> '+'               | Plus(){ input.locus }                     :: { "+" }
> raw_literal       | Raw(string){ input.locus }                :: { "{" ~ value ~ "}" }
> '\n'              | NewLine(){ input.locus }                  :: { "\n" }
> '!'               | Not(){ input.locus }                      :: { "!" }
> '$'               | Dollar(){ input.locus }                   :: { "$" }
> '>'               | Enter(){ input.locus }                    :: { ">" }

scan : (Input) -> Token[] | Token.match*:t -> filter_out_whitespaces(t)

filter_out_whitespaces : (Token[])                                  -> Token[]
                       | $                                          -> []
                       | Token.Whitespace* filter_out_whitespaces:t -> t
                       | . filter_out_whitespaces:t                 -> t

identifier : (Input)                               -> Token
           | identifier_non_digit identifier_rest* -> Token.Identifier(input.locus, result)

identifier_non_digit : (Input) -> char | 'a' .. 'z' | 'A' .. 'Z' | '_'

identifier_rest : (Input) -> char | identifier_non_digit | '0' .. '9'

character_literal : (Input)           -> char
                  | "'" c_char*:c "'" -> check_character_literal(c, input.locus)

check_character_literal : (string, locus : Locus) -> char
                        | .:c $                   -> result
                        | .                       -> error("wrong character literal: '" ~ input ~ "'", locus);

c_char : (Input)  -> char
       | '\\' .   -> unescape_char(result)
       | .        -> result

unescape_char = (Input) -> char
              | 'n'     -> '\n'
              | '\\'    -> '\\'
              | 't'     -> '\t'
              | .       -> result

string_literal : (Input) -> string | '"' c_char*:s '"' -> s

raw_literal : (Input) -> string | '{' r_char*:r '}' -> r

r_char = (Input) -> string | '{' r_char* '}' | character_literal | string_literal | .
