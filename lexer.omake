// Omake meta programming language compiler.
// Copyright (C) 2018  Ilmir Usmanov
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

module omake.lexer

import {
  omake.error
}

data Locus(row: long, column: long) {
  rule this : () -> Locus = `row = 1; column = 1;`
  rule advance : (this, c: char) -> void = `if (c == '\n') { row = 1; column++; } else row++;`
}

data Input(string, locus: Locus) {
  rule empty : (this) -> bool = `value.empty()`
  rule front : (this) -> dchar = `empty() ? '\0' : value.front()`
  rule popFront : (this) -> void = `if (empty()) return; locus.advance(front()); value.popFront();`
}

data Token(locus: Locus) { rule match : (Input)                            rule toString : (this) -> string }
| Colon                  { = ":"                  -> `input.locus`         = `":"`                          }
| Equals                 { = "="                  -> `input.locus`         = `"="`                          }
| Whitespace             { = (' ' | '\t' | '\n')* -> `input.locus`         = `" "`                          }
| LeftParen              { = '('                  -> `input.locus`         = `"("`                          }
| RightParen             { = ')'                  -> `input.locus`         = `")"`                          }
| LeftBrace              { = '{'                  -> `input.locus`         = `"{"`                          }
| RightBrace             { = '}'                  -> `input.locus`         = `"}"`                          }
| Arrow                  { = "->"                 -> `input.locus`         = `"->"`                         }
| Comma                  { = ','                  -> `input.locus`         = `","`                          }
| Data                   { = "data"               -> `input.locus`         = `"data"`                       }
| Rule                   { = "rule"               -> `input.locus`         = `"rule"`                       }
| Module                 { = "module"             -> `input.locus`         = `"module"`                     }
| Import                 { = "import"             -> `input.locus`         = `"import"`                     }
| LeftSquare             { = '['                  -> `input.locus`         = `"["`                          }
| RightSquare            { = ']'                  -> `input.locus`         = `"]"`                          }
| Literal(literal)       { = Literal              -> `input.locus, result` = `value.toString()`             }
| Identifier(string)     { = identifier           -> `input.locus, result` = `value`                        }
| DotDot                 { = ".."                 -> `input.locus`         = `".."`                         }
| Dot                    { = '.'                  -> `input.locus`         = `"."`                          }
| Or                     { = '|'                  -> `input.locus`         = `"|"`                          }
| Star                   { = '*'                  -> `input.locus`         = `"*"`                          }
| Query                  { = '?'                  -> `input.locus`         = `"?"`                          }
| Plus                   { = '+'                  -> `input.locus`         = `"+"`                          }
| Raw(string)            { = raw_literal          -> `input.locus, result` = `"{" ~ value ~ "}"`            }
| Dollar                 { = '$'                  -> `input.locus`         = `"$"`                          }
| Error(char)            { = .                    -> `input.locus, result` = `value`                        }

data Literal      { rule match : (Input)                                               rule toString : (this) -> string }
| Char(char)      { = ["'" c_char*:c "'"] -> `check_character_literal(c, input.locus)` = `"'" ~ value ~ "'"`            }
| String(string)  { = ['"' c_char*:s '"']                                              = `"\"" ~ value ~ "\""`          }
| Null            { = ["null"           ]                                              = "null"                         }

rule scan : (Input) -> Token[] = Token*:t -> `filter_out_whitespaces(t)`

rule filter_out_whitespaces : (Token[]) -> Token[] = (Token.Whitespace:_ .*)* -> `check_for_errors(result)`

rule check_for_errors : (Token[])           -> Token[]
                      = [.* Token.Error:e]  -> `error("Unexpected character: '" ~ e.value ~ "', e.locus)`
                      | [.*              ]

rule identifier : (Input) -> string = identifier_non_digit identifier_rest*

rule identifier_non_digit : (Input) -> char = 'a' .. 'z' | 'A' .. 'Z' | '_'

rule identifier_rest : (Input) -> char = identifier_non_digit | '0' .. '9'

rule check_character_literal : (string, locus : Locus) -> char
                             = [. $]                   -> `result`
                             | [.  ]                   -> `error("wrong character literal: '" ~ input ~ "'", locus)`

rule c_char : (Input)  -> char
            = ['\\' .] -> `unescape_char(result)`
            | [.     ] -> `result`

rule unescape_char : (Input) -> char
                   = 'n'     -> `'\n'`
                   | '\\'    -> `'\\'`
                   | 't'     -> `'\t'`
                   | .       -> `result`

rule raw_literal : (Input) -> string = ['`' .*:r '`' -> `r`]
