// Omake meta programming language compiler.
// Copyright (C) 2018  Ilmir Usmanov
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

module omake.lexer

import {
  omake.error
}

data Locus(row: long, column: long) {
  rule this : () -> Locus = `row = 1; column = 1;`
  rule advance : (this, c: char) -> void = `if (c == '\n') { row = 1; column++; } else row++;`
}

data Input(string, locus: Locus) {
  rule empty : (this) -> bool = `value.empty()`
  rule front : (this) -> dchar = `empty() ? '\0' : value.front()`
  rule popFront : (this) -> void = `if (empty()) return; locus.advance(front()); value.popFront();`
}

data Token(locus: Locus) = Colon | Equals | Whitespace | LeftParen | RightParen
                         | LeftBrace | RightBrace | Arrow | Comma | Data | Rule
                         | Module | Import | LeftSquare | RightSquare | Literal(literal)
                         | Identifier(string) | DotDot | Dot | Or | Star | Query
                         | Plus | Raw(string) | Dollar | Error(char) {
  rule match : (Input) = [":"]                   -> `Colon(input.locus)`
                       | ["="]                   -> `Equals(input.locus)`
                       | [' '] | ['\t'] | ['\n'] -> `Whitespace(input.locus)`
                       | ['(']                   -> `LeftParen(input.locus)`
                       | [')']                   -> `RightParen(input.locus)`
                       | ['{']                   -> `LeftBrace(input.locus)`
                       | ['}']                   -> `RightBrace(input.locus)`
                       | ["->"]                  -> `Arrow(input.locus)`
                       | [',']                   -> `Comma(input.locus)`
                       | ["data]"                -> `Data(input.locus)`
                       | ["rule]"                -> `Rule(input.locus)`
                       | ["module]"              -> `Module(input.locus)`
                       | ["import]"              -> `Import(input.locus)`
                       | ['[']                   -> `LeftSquare(input.locus)`
                       | [']']                   -> `RightSquare(input.locus)`
                       | [Literal]               -> `Literal(input.locus, result)`
                       | [identifier]            -> `Identifier(input.locus, result)`
                       | [".."]                  -> `DotDot(input.locus)`
                       | ['.']                   -> `Dot(input.locus)`
                       | ['|']                   -> `Or(input.locus)`
                       | ['*']                   -> `Star(input.locus)`
                       | ['?']                   -> `Query(input.locus)`
                       | ['+']                   -> `Plus(input.locus)`
                       | [raw_literal]           -> `Raw(input.locus, result)`
                       | ['$']                   -> `Dollar(input.locus)`
                       | [.]                     -> `Error(input.locus, result)`
  rule toString : (this) -> string = Colon          -> `":"`
                                   | Equals         -> `"="`
                                   | Whitespace     -> `" "`
                                   | LeftParen      -> `"("`
                                   | RightParen     -> `")"`
                                   | LeftBrace      -> `"{"`
                                   | RightBrace     -> `"}"`
                                   | Arrow          -> `"->"`
                                   | Comma          -> `","`
                                   | Data           -> `"data"`
                                   | Rule           -> `"rule"`
                                   | Module         -> `"module"`
                                   | Import         -> `"import"`
                                   | LeftSquare     -> `"["`
                                   | RightSquare    -> `"]"`
                                   | Literal(:v)    -> `v.toString()`
                                   | Identifier(:v) -> `v`
                                   | DotDot         -> `".."`
                                   | Dot            -> `"."`
                                   | Or             -> `"|"`
                                   | Star           -> `"*"`
                                   | Query          -> `"?"`
                                   | Plus           -> `"+"`
                                   | Raw(:v)        -> `"{" ~ v ~ "}"`
                                   | Dollar         -> `"$"`
                                   | Error(:v)      -> `v`
}

data Literal = Char(char)
             | String(string)
             | Null {
  rule match : (Input) = ["'" c_char*:c "'"] -> `Char(check_character_literal(c, input.locus))`
                       | ['"' c_char*:s '"'] -> `String(s)`
                       | ["null"]            -> `Null`
  rule toString : (this) -> string = Char(:v)   -> `"'" ~ v ~ "'"`
                                   | String(:v) -> `"\"" ~ v ~ "\""`
                                   | Null       -> `"null"`
}

rule scan : (Input) -> Token[] = Token*:t -> `filter_out_whitespaces(t)`

rule filter_out_whitespaces : (Token[]) -> Token[] = (Token.Whitespace:_ .*)* -> `check_for_errors(result)`

rule check_for_errors : (Token[])           -> Token[]
                      = [.* Token.Error:e]  -> `error("Unexpected character: '" ~ e.value ~ "', e.locus)`
                      | [.*              ]

rule identifier : (Input) -> string = identifier_non_digit identifier_rest*

rule identifier_non_digit : (Input) -> char = 'a' .. 'z' | 'A' .. 'Z' | '_'

rule identifier_rest : (Input) -> char = identifier_non_digit | '0' .. '9'

rule check_character_literal : (string, locus : Locus) -> char
                             = [. $]                   -> `result`
                             | [.]                     -> `error("wrong character literal: '" ~ input ~ "'", locus)`

rule c_char : (Input)  -> char
            = ['\\' .] -> `unescape_char(result)`
            | [.]      -> `result`

rule unescape_char : (Input) -> char
                   = 'n'     -> `'\n'`
                   | '\\'    -> `'\\'`
                   | 't'     -> `'\t'`
                   | .       -> `result`

rule raw_literal : (Input) -> string = ['`' .*:r '`'] -> `r`
